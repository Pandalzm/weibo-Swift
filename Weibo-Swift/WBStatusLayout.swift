//
//  WBStatusLayout.swift
//  Weibo-Swift
//
//  Created by PandaLZMing on 16/1/23.
//  Copyright ¬© 2016Âπ¥ PandaLZMing. All rights reserved.
//

import Foundation
import YYText
import Kingfisher
import YYImage

// Âç°ÁâáÁ±ªÂûã
enum WBStatusCardType {
    case WBStatusCardTypeNone
    case WBStatusCardTypeNormal
    case WBStatusCardTypeVideo
}

// Ê†áÁ≠æÁ±ªÂûã
enum WBStatusTagType {
    case WBStatusTagTypeNone
    case WBStatusTagTypeNormal
    case WBStatusTagTypePlace
}



/// ÂæÆÂçöÂ∏ÉÂ±ÄËÆ°ÁÆó
class WBStatusLayout {
    // È´òÂ∫¶
    let kWBCellTitleHeight: CGFloat = 36     // Ê†áÈ¢òÈ´òÂ∫¶
    let kWBCellProfileHeight: CGFloat = 56   // ÂêçÁâáÈ´òÂ∫¶
    let kWBCellToolbarHeight: CGFloat = 35   // Â∑•ÂÖ∑Ê†èÈ´òÂ∫¶
    
    
    // ÂÆΩÂ∫¶
    let kWBCellNameWidth: CGFloat = kScreenWidth() - 110    // ÂêçÂ≠óÊúÄÂ§ßÂÆΩÂ∫¶
    let kWBCellPadding: CGFloat! = 12                       // cellÂÜÖËæπÊ°Ü
    let kWBCellPaddingText: CGFloat = 10                    // ÊñáÊú¨‰∏éÂÖ∂‰ªñÂÖÉÁ¥†ÁöÑÁïôÁôΩ e.g. "xxx üê∞ xxx"
    let kWBCellContentWidth: CGFloat                        // ÂÜÖÂÆπÂÆΩÂ∫¶ kScreenWidth() - 2 * kWBCellPadding ---> | |xxxxxxxxx| |
    let kWBCellPaddingPic: CGFloat = 4                      // Â§öÂõæÈó¥ÁöÑÁïôÁôΩ
    
    // Â≠ó‰Ωì
    let kWBCellNameFontSize: CGFloat = 14        // ÂêçÂ≠óÂ≠ó‰ΩìÂ§ßÂ∞è
    let kWBCellTitlebarFontSize: CGFloat = 14    // Ê†áÈ¢òÊ†èÂ≠ó‰ΩìÂ§ßÂ∞è
    let kWBCellSourceFontSize: CGFloat = 12      // Êù•Ê∫êÂ≠ó‰ΩìÂ§ßÂ∞è
    let kWBCellTextFontRetweetSize: CGFloat = 16 // ËΩ¨ÂèëÂ≠ó‰ΩìÂ§ßÂ∞è
    let kWBCellCardTitleFontSize: CGFloat = 10   // Âç°ÁâáÊ†áÈ¢òÊñáÊú¨Â≠ó‰ΩìÂ§ßÂ∞è
    let kWBCellCardDescFontSize: CGFloat = 12    // Âç°ÁâáÊèèËø∞ÊñáÊú¨Â≠ó‰ΩìÂ§ßÂ∞è
    let kWBCellTextFontSize: CGFloat = 17        // Ê≠£ÊñáÊñáÊú¨Â≠ó‰ΩìÂ§ßÂ∞è
    let kWBCellToolbarFontSize: CGFloat = 14     // Â∑•ÂÖ∑Ê†èÂ≠ó‰ΩìÂ§ßÂ∞è
    
    // È¢úËâ≤
    let kWBCellNameOrangeColor: UIColor! = UIColor(hexString: "f26220")      // Ê©ôËâ≤È¢úËâ≤
    let kWBCellToolbarTitleColor: UIColor! = UIColor(hexString:"929292")     // Â∑•ÂÖ∑Ê†èÊñáÊú¨Ëâ≤
    let kWBCellNameNormalColor: UIColor! = UIColor(hexString: "333333")      // ÂêçÂ≠óÈ¢úËâ≤
    let kWBCellTimeNormalColor: UIColor! = UIColor(hexString: "828282")      // Êó∂Èó¥È¢úËâ≤
    let kWBCellTextHighlightColor: UIColor! = UIColor(hexString: "527ead")   // ÈìæÊé•È¢úËâ≤
    let kWBCellTextSubTitleColor: UIColor! = UIColor(hexString: "5d5d5d")    // Ê¨°Ë¶ÅÊñáÊú¨Ëâ≤(ËΩ¨Âèë)
    let kWBCellTextNormalColor: UIColor! = UIColor(hexString: "333333")      // ‰∏ÄËà¨ÊñáÊú¨Ëâ≤
    
    // Âõ∫ÂÆöÂ≠óÁ¨¶
    let kWBLinkHrefName: String! = "href"
    let kWBLinkURLName: String! = "url"
    let kWBLinkAtName: String! = "at"
    let kWBLinkTagName: String! = "tag"
    
    //-------------------------------------------------------------------------------------------

    // Êï∞ÊçÆ
    let status: WBStatus
    
    // È°∂ÈÉ®ÁÅ∞Ëâ≤ÁïôÁôΩ
    let marginTop: CGFloat = 8
    
    // Ê†áÈ¢òÊ†è
    var titleHeight: CGFloat = 0  // Ê†áÈ¢òÊ†èÈ´òÂ∫¶ÔºåÈªòËÆ§‰∏∫0ÔºåÂ¶ÇÊûú‰∏∫0ÔºåÂàô‰ª£Ë°®Ëøô‰∏ÄÈÉ®ÂàÜÂπ∂Ê≤°ÊúâÂú®ËøôÊù°ÂæÆÂçö‰∏≠ÊòæÁ§∫Ôºå‰∏ãÂêå
    var titleTextLayout : YYTextLayout?
    
    // ‰∏™‰∫∫ËµÑÊñô
    var profileHeight: CGFloat = 0  // ‰∏™‰∫∫ËµÑÊñôÈ´òÂ∫¶ÔºàÂåÖÊã¨‰∏ä‰∏ãÁïôÁôΩÔºâ
    var nameTextLayout: YYTextLayout!  // ÂêçÂ≠ó
    var sourceTextLayout: YYTextLayout!  //  Êó∂Èó¥ÂíåÊù•Ê∫ê
    
    // Ê≠£ÊñáÊñáÊú¨
    var textHeight: CGFloat = 0  // Ê≠£ÊñáÊñáÊú¨È´òÂ∫¶ (ÂåÖÊã¨‰∏ä‰∏ãÁïôÁôΩ)
    var textLayout: YYTextLayout?  // ÊñáÊú¨
    
    // ÂõæÁâá
    var picHeight: CGFloat = 0  // ÂõæÁâáÈ´òÂ∫¶
    var picSize: CGSize?
    
    // ËΩ¨Âèë
    var retweetHeight: CGFloat = 0  // ËΩ¨ÂèëÈ´òÂ∫¶
    var retweetTextHeight: CGFloat = 0
    var retweetTextLayout: YYTextLayout?
    var retweetPicHeight: CGFloat = 0
    var retweetPicSize: CGSize?
    // ËΩ¨Âèë‰∏≠ÁöÑÂç°Áâá
    var retweetCardHeight: CGFloat = 0  // ËΩ¨Âèë‰∏≠ÁöÑÂç°ÁâáÈ´òÂ∫¶
    var retweetCardTextLayout: YYTextLayout?
    var retweetCardType: WBStatusCardType = .WBStatusCardTypeNone
    var retweetCardText: YYTextLayout?
    var retweetCardTextRect: CGRect?
    
    // Âç°Áâá
    var cardHeight: CGFloat = 0  // Âç°ÁâáÈ´òÂ∫¶
    var cardType: WBStatusCardType = .WBStatusCardTypeNone
    var cardTextLayout: YYTextLayout?
    var cardTextRect: CGRect?
    
    // Ê†áÁ≠æ
    var tagHeight: CGFloat = 0  // Ê†áÁ≠æÈ´òÂ∫¶
    var tagType: WBStatusTagType = .WBStatusTagTypeNone
    var tagTextLayout: YYTextLayout?
    
    // Â∑•ÂÖ∑Ê†è ÔºçÔºçÔºç>> |  ËΩ¨Âèë  |  ËØÑËÆ∫  |   ÁÇπËµû  ÔΩú
    var toolbarHeight: CGFloat =  35
    var toolbarRepostTextLayout: YYTextLayout?
    var toolbarCommentTextLayout: YYTextLayout?
    var toolbarLikeTextLayout: YYTextLayout?
    var toolbarRepostTextWidth: CGFloat = 0
    var toolbarCommentTextWidth: CGFloat = 0
    var toolbarLikeTextWidth: CGFloat = 0
    
    // ‰∏ãÈÉ®ÁïôÁôΩ
    var marginBottom: CGFloat = 2
    
    //  ÊÄªÈ´òÂ∫¶
    var height: CGFloat = 0
    
    init? (status: WBStatus) {
        self.status = status
        self.kWBCellContentWidth = kScreenWidth() - 2 * kWBCellPadding
        if status.user == nil {return nil}
        // ËøõË°åÂ∏ÉÂ±ÄËÆ°ÁÆó
        self.layout()
    }
    
    func layout() {
        // Â∏ÉÂ±ÄËÆ°ÁÆó
        self.layoutTitle()
        self.layoutProfile()
        self.layoutRetweet()
        if self.retweetHeight == 0 {
            if self.picHeight == 0 {
                self.layoutCard()
            }
        }
        
        self.layoutText()
        self.layoutTag()
        self.layoutToolBar()
        
        // È´òÂ∫¶ËÆ°ÁÆó
        self.height = 0
        self.height += self.marginTop
        self.height += self.titleHeight
        self.height += self.profileHeight
        self.height += self.textHeight
        if self.retweetHeight > 0 {
            self.height += self.retweetHeight
        } else if (self.picHeight > 0) {
            self.height += self.picHeight
        } else if (self.cardHeight > 0) {
            self.height += self.cardHeight
        }
        if self.tagHeight > 0 {
            self.height += self.tagHeight
        } else {
            if self.picHeight > 0 || self.cardHeight > 0 {
                self.height += kWBCellPadding
            }
        }
        self.height += self.toolbarHeight
        self.height += self.marginBottom
    }

    /// Ê†áÈ¢òÂ∏ÉÂ±ÄËÆ°ÁÆó (‰æãÂ¶Ç‚ÄúÁÉ≠Èó®‚Äù‚ÄúÊé®Ëçê‚Äù)
    func layoutTitle() {
        self.titleHeight = 0
        self.titleTextLayout = nil
        
        let title = self.status.title
        if title == nil || title?.text.characters.count == 0 {return}
        
        let text = NSMutableAttributedString(string: (title?.text)!)
        if title?.iconURL != nil {
            let icon: NSAttributedString = self.attachment(kWBCellTitlebarFontSize, imageURL: (title?.iconURL)!, shrink: false)
            text.insertAttributedString(icon, atIndex: 0)
        }
        text.yy_color = kWBCellToolbarTitleColor
        text.yy_font =  UIFont.systemFontOfSize(kWBCellTitlebarFontSize)

        let container = YYTextContainer(size: CGSize(width: kScreenWidth() - 100, height: kWBCellTitleHeight))
        self.titleTextLayout = YYTextLayout(container: container, text: text)
        self.titleHeight = kWBCellTitleHeight
    }
    
    /// Â§¥ÈÉ®Â∏ÉÂ±ÄËÆ°ÁÆó (ÂåÖÊã¨Â§¥ÂÉè, ÂêçÁß∞, Êó∂Èó¥Á≠âÁ≠â)
    func layoutProfile() {
        self.layoutName()
        self.layoutSourse()
        self.profileHeight = kWBCellProfileHeight
    }
    
    /// ÂêçÂ≠ó
    func layoutName() {
        let user:WBUser = self.status.user!
        var nameStr: String!
        if user.remark != nil && user.remark!.characters.count > 0 {
            nameStr = user.remark!
        } else {
            nameStr = user.name!
        }
        if nameStr.characters.count == 0 {
            self.nameTextLayout = nil
            return
        }
        
        let nameText: NSMutableAttributedString = NSMutableAttributedString(string: nameStr)
        
        // ËìùV
        if user.userVerifyType == WBUserVerifyType.WBUserVerifyTypeClub {
            let blueVImage: UIImage = WBStatusHelper().imageNamed("avatar_enterprise_vip")!
            let blueVText: NSAttributedString = self.attachment(kWBCellNameFontSize, image: blueVImage, shrink: false)
            nameText.yy_appendString(" ")
            nameText.appendAttributedString(blueVText)
        }
        
        // VIP
        if user.mbrank > 0 {
            var yellowVImage: UIImage? = WBStatusHelper().imageNamed("common_icon_membership_level\(user.mbrank)")
            if yellowVImage == nil {
                yellowVImage = WBStatusHelper().imageNamed("common_icon_membership")
            }
            let vipText: NSAttributedString! = self.attachment(kWBCellNameFontSize, image: yellowVImage!, shrink: false)
            nameText.yy_appendString(" ")
            nameText.appendAttributedString(vipText)
        }
        nameText.yy_font = UIFont.systemFontOfSize(kWBCellNameFontSize)
        nameText.yy_color = user.mbrank > 0 ? kWBCellNameOrangeColor : kWBCellNameNormalColor
        
        let container = YYTextContainer(size: CGSizeMake(kWBCellNameWidth, 9999))
        container.maximumNumberOfRows = 1
        self.nameTextLayout = YYTextLayout(container: container, text: nameText)
    }
    
    /// Êù•Ê∫ê
    func layoutSourse() {
        let sourceText: NSMutableAttributedString! = NSMutableAttributedString()
        let createTime: String = WBStatusHelper().stringWithTimeLineDate(self.status.createdAt)
        
        // Êó∂Èó¥
        if createTime.characters.count != 0{
            let timeText: NSMutableAttributedString = NSMutableAttributedString(string: createTime)
            timeText.yy_appendString("  ")
            timeText.yy_font = UIFont.systemFontOfSize(kWBCellSourceFontSize)
            timeText.yy_color = kWBCellTimeNormalColor
        }
        
        // Êù•Ëá™ XXX
        if self.status.source.characters.count != 0 {
            // <a href="sinaweibo://customweibosource" rel="nofollow">iPhone 5siPhone 5s</a>
            struct Static {     //  Ê≠£ÂàôÂåπÈÖç
                static var hrefRegex: NSRegularExpression! = NSRegularExpression()
                static var textRegex: NSRegularExpression! = NSRegularExpression()
                static var onceToken: dispatch_once_t = 0
            }
            dispatch_once(&Static.onceToken, { () -> Void in
                Static.hrefRegex = try! NSRegularExpression(pattern:"(?<=href=\").+(?=\" )", options: .CaseInsensitive)
                Static.textRegex = try! NSRegularExpression(pattern:"(?<=>).+(?=<)", options: .CaseInsensitive)
            })
            
            var hrefResult: NSTextCheckingResult?
            var textResult: NSTextCheckingResult?
            var href: NSString?
            var text: NSString?
            hrefResult = Static.hrefRegex.firstMatchInString(self.status.source, options:[], range: NSMakeRange(0, self.status.source.characters.count))!
            textResult = Static.hrefRegex.firstMatchInString(self.status.source, options:[], range: NSMakeRange(0, self.status.source.characters.count))!
            if hrefResult != nil && textResult != nil && hrefResult!.range.location != NSNotFound && textResult!.range.location != NSNotFound {
                href = (self.status.source as NSString).substringWithRange(hrefResult!.range)
                text = (self.status.source as NSString).substringWithRange(textResult!.range)
            }
            if href != nil && text != nil && href?.length > 0 && text?.length > 0 {
                let from: NSMutableAttributedString = NSMutableAttributedString()
                from.yy_appendString("Êù•Ëá™ \(text)")
                from.yy_font = UIFont.systemFontOfSize(kWBCellSourceFontSize)
                from.yy_color = kWBCellTimeNormalColor
                if self.status.sourceAllowClick > 0 {       // ÂÖÅËÆ∏ÁÇπÂáª,Â≠ó‰Ωì‰∏∫ËìùËâ≤ÔºåËÄå‰∏îÊúâÁÇπÂáªÊïàÊûú
                    let range: NSRange! = NSMakeRange(3, text!.length)
                    from.yy_setColor(kWBCellTextHighlightColor, range: range)
                    
                    let backed: YYTextBackedString = YYTextBackedString(string: (href as! String))
                    from.yy_setTextBackedString(backed, range: range)
                    
                    let border: YYTextBorder = YYTextBorder()
                    border.insets = UIEdgeInsetsMake(-2, 0, -2, 0)
                    border.fillColor = kWBCellTextHighlightColor
                    border.cornerRadius = 3
                    
                    let highlight: YYTextHighlight = YYTextHighlight()
                    highlight.userInfo = [kWBLinkHrefName : href!]
                    highlight.setBackgroundBorder(border)
                    from.yy_setTextHighlight(highlight, range: range)
                }
                sourceText.appendAttributedString(from)
            }
        }
        
        if sourceText.length == 0 {
            self.sourceTextLayout = nil
        } else {
            let container = YYTextContainer(size: CGSizeMake(kWBCellNameWidth, 9999))
            container.maximumNumberOfRows = 1
            self.sourceTextLayout = YYTextLayout(container: container, text: sourceText)
        }
    }
    
    /// ÂæÆÂçöÊ≠£Êñá
    func layoutText() {
        self.textHeight = 0
        self.textLayout = nil
        
        let text: NSMutableAttributedString? = self.textWithStatus(self.status, isRetweet: false, fontSize: kWBCellTextFontSize, textColor: kWBCellTextNormalColor)
        
        if text == nil || text?.length == 0 { return }
        
        let modifier: WBTextLinePositionModifier! = WBTextLinePositionModifier()
        modifier.font = UIFont(name: "Heiti SC", size: kWBCellTextFontSize)
        modifier.paddingTop = Float(kWBCellPaddingText)
        modifier.paddingBottm = Float(kWBCellPaddingText)
        
        let container: YYTextContainer! = YYTextContainer()
        container.size = CGSizeMake(kWBCellContentWidth,CGFloat(HUGE))
        container.linePositionModifier = modifier
        
        self.textLayout = YYTextLayout(container: container, text: text)
        if self.textLayout == nil { return }
        
        self.textHeight = CGFloat(modifier.heightForLineCount(Int((self.textLayout?.rowCount)!))!)
    }
    
    /// ÂæÆÂçöÊ†áÁ≠æ
    func layoutTag() {
        self.tagType = .WBStatusTagTypeNone
        self.tagHeight = 0
        
        let tag:WBTag? = self.status.tagStruct.first
        if tag == nil || tag!.tagName?.length == 0 { return }
        
        let text: NSMutableAttributedString = NSMutableAttributedString(string: tag!.tagName!)
        
        if tag!.tagType == 1{
            self.tagType = .WBStatusTagTypePlace
            self.tagHeight = 40
            text.yy_color = UIColor(white: 0.217, alpha: 1.000)
        } else {
            self.tagType = .WBStatusTagTypeNormal
            self.tagHeight = 32
            if tag!.urlTypePic != nil {
                let pic: NSAttributedString = self.attachment(kWBCellCardDescFontSize, imageURL: tag!.urlTypePic!.absoluteString, shrink: true)
                text.insertAttributedString(pic, atIndex: 0)
            }
            
            // È´ò‰∫ÆÁä∂ÊÄÅËÉåÊôØ
            let highlightBorder: YYTextBorder = YYTextBorder()
            highlightBorder.insets = UIEdgeInsetsMake(-2, 0, -2, 0)
            highlightBorder.cornerRadius = 2
            highlightBorder.fillColor = kWBCellTextHighlightColor
            text.yy_setColor(kWBCellTextHighlightColor, range: NSMakeRange(0, text.length))
            
            // È´ò‰∫ÆÁä∂ÊÄÅ
            let highlight: YYTextHighlight = YYTextHighlight()
            highlight.setBackgroundBorder(highlightBorder)
            
            // Êï∞ÊçÆ‰ø°ÊÅØ
            highlight.userInfo = [kWBLinkTagName : tag!]
            text.yy_setTextHighlight(highlight, range: NSMakeRange(0, text.length))
        }
        
        text.yy_font = UIFont.systemFontOfSize(kWBCellCardDescFontSize)
        
        let container: YYTextContainer! = YYTextContainer(size: CGSizeMake(9999, 9999))
        self.tagTextLayout = YYTextLayout(container: container, text: text)
        if self.tagTextLayout == nil {
            self.tagType = .WBStatusTagTypeNone
            self.tagHeight = 0
        }
    }
    
    /// ÂæÆÂçöÂ∑•ÂÖ∑Ê†è 
    func layoutToolBar() {
        let font: UIFont! = UIFont.systemFontOfSize(kWBCellToolbarFontSize)
        let container: YYTextContainer = YYTextContainer(size: CGSizeMake(kScreenWidth(), kWBCellToolbarHeight))
        container.maximumNumberOfRows = 1
        
        let repostText: NSMutableAttributedString = NSMutableAttributedString(string: self.status.repostsCount <= 0 ? "ËΩ¨Âèë" : WBStatusHelper().shortedNumberDesc(Int(self.status.repostsCount)))
        repostText.yy_font = font
        repostText.yy_color = kWBCellToolbarTitleColor
        self.toolbarRepostTextLayout = YYTextLayout(container: container, text: repostText)
        self.toolbarRepostTextWidth = CGFloatPixelRound(self.toolbarRepostTextLayout!.textBoundingRect.size.width)
        
        let commentText: NSMutableAttributedString = NSMutableAttributedString(string: self.status.commentsCount <= 0 ? "ËØÑËÆ∫" : WBStatusHelper().shortedNumberDesc(Int(self.status.commentsCount)))
        commentText.yy_font = font
        commentText.yy_color = kWBCellToolbarTitleColor
        self.toolbarCommentTextLayout = YYTextLayout(container: container, text: commentText)
        self.toolbarCommentTextWidth = CGFloatPixelRound(self.toolbarCommentTextLayout!.textBoundingRect.size.width)
        
        let likeText: NSMutableAttributedString = NSMutableAttributedString(string: self.status.attitudesCount <= 0 ? "Ëµû" : WBStatusHelper().shortedNumberDesc(Int(self.status.attitudesCount)))
        likeText.yy_font = font
        likeText.yy_color = kWBCellToolbarTitleColor
        self.toolbarLikeTextLayout = YYTextLayout(container: container, text: likeText)
        self.toolbarLikeTextWidth = CGFloatPixelRound(self.toolbarLikeTextLayout!.textBoundingRect.size.width)
    }

    /// ËΩ¨ÂèëÂæÆÂçö
    func layoutRetweet() {
        self.retweetHeight = 0
        self.layoutRetweetedText()
        self.layoutRetweetPics()
        
        if self.retweetPicHeight == 0 {
            self.layoutRetweetCard()
        }
        
        self.retweetHeight = self.retweetTextHeight
        if self.retweetPicHeight > 0 {  // ‰∏§ËÄÖÂè™ËÉΩÂ≠òÂú®‰∏Ä‰∏™
            self.retweetHeight += self.retweetHeight
            self.retweetHeight += kWBCellPadding // padding
        } else if self.retweetCardHeight > 0 {
            self.retweetHeight += self.retweetCardHeight
            self.retweetHeight += kWBCellPadding // padding
        }
    }
    
    /// ËΩ¨ÂèëÂæÆÂçö‰∏≠Ê≠£Êñá
    func layoutRetweetedText() {
        self.retweetHeight = 0
        self.retweetTextLayout = nil
        let text: NSMutableAttributedString? = self.textWithStatus(self.status.retweetedStatus, isRetweet: true, fontSize: kWBCellTextFontRetweetSize, textColor: kWBCellTextSubTitleColor)
        
        if text == nil || text!.length == 0 { return }
        
        let modifier: WBTextLinePositionModifier! = WBTextLinePositionModifier()
        modifier.font = UIFont(name: "Heiti SC", size: kWBCellTextFontRetweetSize)
        modifier.paddingTop = Float(kWBCellPaddingText)
        modifier.paddingBottm = Float(kWBCellPaddingText)
        
        let container: YYTextContainer = YYTextContainer()
        container.size = CGSizeMake(kWBCellContentWidth, CGFloat(HUGE))
        container.linePositionModifier = modifier
        
        self.retweetTextLayout = YYTextLayout(container: container, text: text)
        if self.retweetTextLayout == nil { return }
        self.retweetTextHeight = CGFloat(modifier.heightForLineCount(self.retweetTextLayout?.lines.count)!)
    }
    
    /// ÂæÆÂçöÂç°Áâá
    func layoutCard() {
        self.layoutCardWithStatus(self.status, isRetweet: false)
    }
    
    /// ËΩ¨ÂèëÂæÆÂçöÂç°Áâá
    func layoutRetweetCard() {
        self.layoutCardWithStatus(self.status.retweetedStatus, isRetweet: true)
    }
    
    /// Ê†πÊçÆÂæÆÂçö‰∏≠ÁöÑÂç°ÁâáËøõË°åËΩ¨Âåñ
    func layoutCardWithStatus(status: WBStatus?, isRetweet: Bool) {
        if status == nil { return }
        if isRetweet == true {
            self.retweetCardType = WBStatusCardType.WBStatusCardTypeNone
            self.retweetCardHeight = 0
            self.retweetCardTextLayout = nil
            self.retweetCardTextRect = CGRectZero
        } else {
            self.cardType = WBStatusCardType.WBStatusCardTypeNone
            self.cardHeight = 0
            self.cardTextLayout = nil
            self.cardTextRect = CGRectZero
        }
        
        let pageInfo: WBPageInfo? = status!.pageInfo
        if pageInfo == nil { return }
        
        var cardType: WBStatusCardType! = WBStatusCardType.WBStatusCardTypeNone
        var cardHeight: CGFloat! = 0
        var cardTextLayout: YYTextLayout?
        var textRect: CGRect! = CGRectZero
        
        if pageInfo!.type == 11 && pageInfo!.objectType == "video" {    // ËßÜÈ¢ëÂç°Áâá 
            if pageInfo!.pagePic != nil {
                cardType = WBStatusCardType.WBStatusCardTypeVideo
                cardHeight = (2 * kWBCellContentWidth - kWBCellPaddingPic) / 3
            }
        } else {
            let hasImage: Bool! = (pageInfo!.pagePic != nil)    // Â∑¶‰æßÂõæ
            let hasBadge: Bool! = (pageInfo!.typeIcon != nil)   // ÂõæÁöÑÁ±ªÂûãÂõæÊ†á
            let button:WBButtonLink? = pageInfo!.buttons?.first
            let hasButton: Bool! = button?.pic != nil && button?.name != nil
            
            /*
            Âç°ÁâáÊï∞ÊçÆ
            badge(‰∏ÄËà¨‰∏∫Â∑¶‰∏äËßíÂ∞èÂõæÊ†á)   : 25 * 25
            image(‰∏ÄËà¨‰∏∫Â∑¶ÊñπÂõæÁâá)      : ÊñπÂΩ¢Ôºà70 * 70); Áü©ÂΩ¢(100 * 70)
            btn(‰∏ÄËà¨‰∏∫Âè≥‰æßÊåâÈíÆ)        : 60 * 70
            lineHeight(ÊñáÂ≠óÈ´òÂ∫¶)      : 20
            padding(Êéß‰ª∂Èó¥Ë∑ù)         : 10
            */
            
            textRect.size.height = 70
            if hasImage == true {
                if hasBadge == true {
                    textRect.origin.x = 100
                } else {
                    textRect.origin.x = 70
                }
            } else {
                if hasBadge == true {
                    textRect.origin.x = 42
                }
            }
            
            textRect.origin.x += 10 // padding
            textRect.size.width = kWBCellContentWidth - textRect.origin.x
            if hasButton == true { textRect.size.width -= 60 }
            textRect.size.width -= 10 // padding
            
            /*  ‰∏ÄËà¨Âç°ÁâáÊ†∑Âºè(badgeÂú®imageÁöÑÂ∑¶‰∏äËßí)
            ----------------------------
            |        pageTitle         |
            | image  pageDesc   btns   |
            |        tips              |
            ----------------------------
            */
            
            let text: NSMutableAttributedString = NSMutableAttributedString()

            if pageInfo!.pageTitle.length > 0 {         // Ê†áÈ¢ò
                let title: NSMutableAttributedString = NSMutableAttributedString(string: pageInfo!.pageTitle)
                title.yy_font = UIFont.systemFontOfSize(kWBCellCardTitleFontSize)
                title.yy_color = kWBCellNameNormalColor
                text.appendAttributedString(title)
            }
            
            if pageInfo!.pageDesc?.length > 0 {          // Âç°ÁâáÊèèËø∞
                if text.length > 0 { text.yy_appendString("\n") }
                let desc: NSMutableAttributedString = NSMutableAttributedString(string: pageInfo!
                    .pageDesc!)
                desc.yy_font = UIFont.systemFontOfSize(kWBCellCardDescFontSize)
                desc.yy_color = kWBCellNameNormalColor
                text.appendAttributedString(desc)
            } else if pageInfo!.content2?.length > 0 {
                if text.length > 0 { text.yy_appendString("\n") }
                let desc: NSMutableAttributedString = NSMutableAttributedString(string: pageInfo!.pageDesc!)
                desc.yy_font = UIFont.systemFontOfSize(kWBCellCardDescFontSize)
                desc.yy_color = kWBCellNameNormalColor
                text.appendAttributedString(desc)
            } else if pageInfo!.content3?.length > 0 {
                if text.length > 0 { text.yy_appendString("\n") }
                let desc: NSMutableAttributedString = NSMutableAttributedString(string: pageInfo!.pageDesc!)
                desc.yy_font = UIFont.systemFontOfSize(kWBCellCardDescFontSize)
                desc.yy_color = kWBCellNameNormalColor
                text.appendAttributedString(desc)
            } else if pageInfo!.content4?.length > 0 {
                if text.length > 0 { text.yy_appendString("\n") }
                let desc: NSMutableAttributedString = NSMutableAttributedString(string: pageInfo!.pageDesc!)
                desc.yy_font = UIFont.systemFontOfSize(kWBCellCardDescFontSize)
                desc.yy_color = kWBCellNameNormalColor
                text.appendAttributedString(desc)
            }
            
            if pageInfo!.tips?.length > 0 {         // Âç°ÁâáÊèêÁ§∫
                if text.length > 0 { text.yy_appendString("\n") }
                let tips: NSMutableAttributedString = NSMutableAttributedString(string: pageInfo!.tips!)
                tips.yy_font = UIFont.systemFontOfSize(kWBCellCardDescFontSize)
                tips.yy_color = kWBCellTextSubTitleColor
                text.appendAttributedString(tips)
            }
            
            if text.length > 0 {
                text.yy_maximumLineHeight = 20
                text.yy_minimumLineHeight = 20
                text.yy_lineBreakMode = .ByTruncatingTail   //  ---->  xxx...
                
                let container: YYTextContainer = YYTextContainer(size: textRect.size)
                container.maximumNumberOfRows = 3   // ÊúÄÂ§ß‰∏∫‰∏ÄËà¨Ê†∑ÂºèÁöÑ‰∏âË°å
                cardTextLayout = YYTextLayout(container: container, text: text)
            }
            
            if cardTextLayout != nil {
                cardType = .WBStatusCardTypeNormal
                cardHeight = 70     // ÊúÄÈ´ò‰∏∫ÂõæÁâáÁöÑÈ´òÂ∫¶
            }
        }
        
        if isRetweet == true {
            self.retweetCardType = cardType
            self.retweetCardHeight = cardHeight
            self.retweetCardTextLayout = cardTextLayout
            self.retweetCardTextRect = textRect
        } else {
            self.cardType = cardType
            self.cardHeight = cardHeight
            self.cardTextLayout = cardTextLayout
            self.cardTextRect = textRect
        }
    }
    
    /// ÂæÆÂçöÂõæÁâá
    func layoutPics() {
        self.layoutPicsWithStauts(self.status, isRetweet: false)
    }
    
    /// ËΩ¨ÂèëÂæÆÂçöÂõæÁâá
    func layoutRetweetPics() {
        self.layoutPicsWithStauts(self.status.retweetedStatus, isRetweet: true)
    }
    
    /// Ê†πÊçÆÂæÆÂçö‰∏≠ÂõæÁâáËøõË°åËΩ¨Âåñ
    func layoutPicsWithStauts(status: WBStatus?, isRetweet: Bool) {
        if status == nil { return }
        if isRetweet == true {
            self.retweetPicSize = CGSizeZero
            self.retweetPicHeight = 0
        } else {
            self.picSize = CGSizeZero
            self.picHeight = 0
        }
        if status?.pics.count == 0 { return }
        
        var picSize: CGSize = CGSizeZero
        var picHeight: CGFloat = 0
        
        var len1_3: CGFloat = (kWBCellContentWidth + kWBCellPaddingPic) / 3 - kWBCellPaddingPic     // ÊúâÂ§ß‰∫é1Âº†ÂõæÁâáÁöÑÊó∂ÂÄôÂõæÁâáÁöÑÂÆΩÂ∫¶
        len1_3 = CGFloatPixelRound(len1_3)
        
        switch (status!.pics.count) {
        case 1:
            let pic: WBPicture! = status?.pics.first
            let bmiddle: WBPictureMetadata = pic.bmiddle
            if pic.keepSize == true || bmiddle.width < 1 || bmiddle.height < 1 {            // ÂçïÂõæ ‰∏∫Ê≠£ÊñπÂΩ¢ÁöÑÊó∂ÂÄô
                var maxLen: CGFloat = kWBCellContentWidth / 2.0
                maxLen = CGFloatPixelRound(maxLen)
                picSize = CGSizeMake(maxLen, maxLen)
                picHeight = maxLen
            } else {
                let maxlen: CGFloat = len1_3 * 2 + kWBCellPaddingPic
                if bmiddle.width < bmiddle.height {
                    picSize.width = CGFloat(bmiddle.width) / CGFloat(bmiddle.height) * maxlen
                    picSize.height = maxlen
                } else {
                    picSize.width = maxlen
                    picSize.height = CGFloat(bmiddle.height) / CGFloat(bmiddle.width) * maxlen
                }
                picSize = CGSizePixelRound(picSize)
                picHeight = picSize.height
            }
            break
        case 2,3:
            picSize = CGSizeMake(len1_3, len1_3)
            picHeight = len1_3
            break
        case 4,5,6:
            picSize = CGSizeMake(len1_3, len1_3)
            picHeight = len1_3 * 2 + kWBCellPaddingPic
            break
        default:    // 7,8,9
            picSize = CGSizeMake(len1_3, len1_3)
            picHeight = len1_3 * 3 + kWBCellPaddingPic
            break
        }
        
        if isRetweet == true {
            self.retweetPicSize = picSize
            self.retweetPicHeight = picHeight
        } else {
            self.picSize = picSize
            self.picHeight = picHeight
        }
    }
    
    /// Ê†πÊçÆÂæÆÂçöÊ≠£ÊñáËøõË°åËΩ¨Âåñ
    func textWithStatus(status:WBStatus?, isRetweet: Bool, fontSize: CGFloat, textColor: UIColor) -> NSMutableAttributedString? {
        if status == nil { return nil }
        var string: String! = status!.text
        if string.characters.count == 0 { return nil }
        if isRetweet == true {
            var name: String! = status!.user?.name
            if name != nil && name!.characters.count == 0 {
                name = status!.user?.screenName
            }
            if name != nil {
                string = "@\(name):\(string)"
            }
        }
        
        let font: UIFont = UIFont.systemFontOfSize(fontSize)
        
        let highlightBorder: YYTextBorder = YYTextBorder()  // È´ò‰∫ÆÁä∂ÊÄÅÁöÑËÉåÊôØ
        highlightBorder.insets = UIEdgeInsetsMake(-2, 0, -2, 0)
        highlightBorder.cornerRadius = 3
        highlightBorder.fillColor = kWBCellTextHighlightColor
        
        let text: NSMutableAttributedString = NSMutableAttributedString(string: string)
        text.yy_font = font
        text.yy_color = textColor
        
        // Ê†πÊçÆURLÂåπÈÖçÊ≠£Êñá
        for wburl: WBURL in self.status.urlStruct {
            if wburl.shortURL.characters.count == 0 { continue }
            if wburl.urlTitle.characters.count == 0 { continue }
            
            var urlTitle: NSString = wburl.urlTitle
            if urlTitle.length > 27 {   // Â¶ÇÊûúurlÁöÑÊ†áÈ¢òÂ§ß‰∫é27 ,ÂàôÊà™Âèñ
                urlTitle = urlTitle.substringToIndex(27).stringByAppendingString(YYTextTruncationToken)
            }
            
            var searchRange: NSRange = NSMakeRange(0, text.string.characters.count)
            repeat {
                let range: NSRange = (text.string as NSString).rangeOfString(wburl.shortURL, options: [], range: searchRange)
                if range.location == NSNotFound { break }
                
                if range.location + range.length == text.length {   // Â¶ÇÊûúURLÂú®ÁªìÂ∞æ
                    if self.status.pageInfo?.pageID.length > 0 && wburl.pageID.length > 0 &&
                        self.status.pageInfo?.pageID == wburl.pageID {
                            
                            if (isRetweet == false && status?.retweetedStatus == nil) || isRetweet == true {
                                if status?.pics.count == 0{
                                    text.replaceCharactersInRange(range, withString: "")    // Âç°ÁâáÊòæÁ§∫
                                    break
                                }
                            }
                    }
                }
                
                if text.yy_attribute(YYTextHighlightAttributeName, atIndex: UInt(range.location)) == nil {
                    
                    // ÊõøÊç¢Â≠óÁ¨¶ ‰æãÂ¶Ç"Êü•ÁúãÂõæÁâá" ----> "üê∞Êü•ÁúãÂõæÁâá" Ëøô‰∏™"üê∞"ÂõæÁâáÔºåÈúÄË¶ÅÂú®ÁΩëÁªúËé∑Âèñ
                    let replace : NSMutableAttributedString = NSMutableAttributedString(string: (urlTitle as String))
                    
                    if wburl.urlTypeURL.characters.count > 0 {
                        let picURL: NSURL = WBStatusHelper().defaultURLForImageURLStr(wburl.urlTypeURL)!
                        var imageView: UIImageView? = UIImageView()
                        imageView!.kf_setImageWithURL(picURL)
                        let pic: NSAttributedString = (imageView!.image != nil && wburl.pics.count > 0) ? self.attachment(fontSize, image: imageView!.image!, shrink: true) : self.attachment(fontSize, imageURL: wburl.urlTypeURL, shrink: true)
                        replace.insertAttributedString(pic, atIndex: 0)
                        imageView = nil
                    }
                    replace.yy_font = font
                    replace.yy_color = kWBCellTextHighlightColor
                    
                    // È´ò‰∫Æ
                    let highlight: YYTextHighlight = YYTextHighlight()
                    highlight.setBackgroundBorder(highlightBorder)
                    // Êï∞ÊçÆ‰ø°ÊÅØ
                    highlight.userInfo = [kWBLinkURLName : wburl]
                    replace.yy_setTextHighlight(highlight, range: NSMakeRange(0, replace.length))
                    
                    // ÊõøÊç¢ÂéüÂßãÂ≠óÁ¨¶‰∏≤
                    let backed: YYTextBackedString = YYTextBackedString(string: (text.string as NSString).substringWithRange(range))
                    replace.yy_setTextBackedString(backed, range: NSMakeRange(0, replace.length))
                    
                    // ÊúÄÂêéËøõË°åÊõøÊç¢
                    text.replaceCharactersInRange(range, withAttributedString: replace)
                    
                    searchRange.location = searchRange.location + (replace.length > 0 ? replace.length : 1)
                    if searchRange.location + 1 >= text.length { break }
                    searchRange.length = text.length - searchRange.location
                } else {
                    searchRange.location = searchRange.location + (searchRange.length > 0 ? searchRange.length : 0)
                    if searchRange.location + 1 >= text.length { break }
                    searchRange.length = text.length - searchRange.location
                }
            } while(true)
        }
        
        /// ÂåπÈÖçËØùÈ¢ò
        for topic: WBTopic in self.status.topicStruct {
            if topic.topiceTitle.length == 0 { continue }
            let topicTitle: String! = "#\(topic.topiceTitle)#"       // ‰∏§ËæπÊ∑ªÂä†#Âè∑  "XXX" -> "#XXX#"
            var searchRange: NSRange = NSMakeRange(0, text.string.length)
            repeat {
                let range: NSRange = (text.string as NSString).rangeOfString(topicTitle, options: [], range: searchRange)
                if range.location == NSNotFound { break }
                
                if text.yy_attribute(YYTextHighlightAttributeName, atIndex: UInt(range.location)) == nil {
                    text.yy_setColor(kWBCellTextHighlightColor, range: range)
                    
                    // È´ò‰∫Æ
                    let highlight: YYTextHighlight = YYTextHighlight()
                    highlight.setBackgroundBorder(highlightBorder)
                    // Êï∞ÊçÆ‰ø°ÊÅØ
                    highlight.userInfo = [kWBLinkURLName : topic]
                    text.yy_setTextHighlight(highlight, range:range)
                }
                
                searchRange.location = searchRange.location + (searchRange.length > 0 ? searchRange.length : 1)
                if searchRange.location + 1 >= text.length { break }
                searchRange.length = text.length - searchRange.location
            } while (true)
        }

        /// ÂåπÈÖçÁî®Êà∑Âêç ---> @XXX
        let atRestults = WBStatusHelper().regexAt.matchesInString(text.string, options: [], range: NSMakeRange(0, text.length))
        for at: NSTextCheckingResult in atRestults {
            if at.range.location == NSNotFound && at.range.length <= 1 { continue }
            if text.yy_attribute(YYTextHighlightAttributeName, atIndex:UInt(at.range.location)) == nil {
                text.yy_setColor(kWBCellTextHighlightColor, range: at.range)
                
                // È´ò‰∫Æ
                let highlight: YYTextHighlight = YYTextHighlight()
                highlight.setBackgroundBorder(highlightBorder)
                // Êï∞ÊçÆ
                highlight.userInfo = [kWBLinkAtName: (text.string as NSString).substringWithRange(NSMakeRange(at.range.location + 1, at.range.length - 1))]
                text.yy_setTextHighlight(highlight, range: at.range)
            }
        }
        
        /// ÂåπÈÖçË°®ÊÉÖ [üê∞]
        let emotionResults = WBStatusHelper().regexEmotion.matchesInString(text.string, options: [], range: NSMakeRange(0, text.length))
        var emoClipLength: Int = 0
        for emo: NSTextCheckingResult in emotionResults {
            if emo.range.location == NSNotFound && emo.range.length <= 1 { continue }
            var range: NSRange = emo.range
            range.location -= emoClipLength
            if text.yy_attribute(YYTextHighlightAttributeName, atIndex:UInt(range.location)) != nil { continue }
            if text.yy_attribute(YYTextAttachmentAttributeName, atIndex: UInt(range.location)) != nil { continue }
            
            let emoString: NSString = (text.string as NSString).substringWithRange(range)
            let imagePath: NSString? = WBStatusHelper().emoticonDic[emoString] as? NSString
            let image: UIImage? = WBStatusHelper().imageWithPath(imagePath)
            if image == nil { continue }
            
            let emoText: NSAttributedString = NSAttributedString.yy_attachmentStringWithEmojiImage(image, fontSize: fontSize)
            
            text.replaceCharactersInRange(range, withAttributedString: emoText)
            emoClipLength += range.length - 1
        }
        return text
    }
    
    /// ÊñáÊú¨‰∏≠ÁöÑÂõæÁâáËΩ¨Êç¢(Ê†πÊçÆÂõæÁâáURL)
    func attachment(fontSize: CGFloat, imageURL: String, shrink: Bool) -> NSAttributedString {
        let ascent = fontSize * 0.86
        let descent = fontSize * 0.14
        let bounding = CGRectMake(0, -0.14 * fontSize, fontSize, fontSize)
        var contentInsets = UIEdgeInsetsMake(ascent - (bounding.size.height + bounding.origin.y), 0, descent + bounding.origin.y, 0)
        var size = CGSizeMake(fontSize, fontSize)
        
        if shrink {
            let scale: CGFloat = 1 / 10.0
            contentInsets.top += fontSize * scale
            contentInsets.bottom += fontSize * scale
            contentInsets.left += fontSize * scale
            contentInsets.right += fontSize * scale
            contentInsets = UIEdgeInsetPixelFloor(contentInsets)
            size = CGSizeMake(fontSize - fontSize * scale * 2, fontSize - fontSize * scale * 2)
            size = CGSizePixelRound(size)
        }
        let delegate = YYTextRunDelegate()
        delegate.ascent = ascent
        delegate.descent = descent
        delegate.width = bounding.size.width
        
        let attachment = WBTextImageViewAttachment()
        attachment.contentMode = UIViewContentMode.ScaleAspectFit
        attachment.contentInsets = contentInsets
        attachment.size = size
        attachment.imageURL = WBStatusHelper().defaultURLForImageURLStr(imageURL)
        
        let art = NSMutableAttributedString(string: YYTextAttachmentToken)
        art.yy_setTextAttachment(attachment, range: NSMakeRange(0, art.length))
        var ctDelegate = delegate.CTRunDelegate()
        art.yy_setRunDelegate(ctDelegate, range: NSMakeRange(0, art.length))
        if ctDelegate != nil {ctDelegate = nil}

        return art
    }
    
    /// ÊñáÊú¨‰∏≠ÁöÑÂõæÁâáËΩ¨Êç¢(Ê†πÊçÆÂõæÁâá)
    func attachment(fontSize: CGFloat, image: UIImage, shrink: Bool) -> NSAttributedString {
        let ascent = fontSize * 0.86
        let descent = fontSize * 0.14
        let bounding = CGRectMake(0, -0.14 * fontSize, fontSize, fontSize)
        var contentInsets = UIEdgeInsetsMake(ascent - (bounding.size.height + bounding.origin.y), 0, descent + bounding.origin.y, 0)
        
        let delegate = YYTextRunDelegate()
        delegate.ascent = ascent
        delegate.descent = descent
        delegate.width = bounding.size.width
        
        let attachment = WBTextImageViewAttachment()
        attachment.contentMode = UIViewContentMode.ScaleAspectFit
        attachment.content = image
        
        if shrink {
            let scale: CGFloat = 1 / 10.0
            contentInsets.top += fontSize * scale
            contentInsets.bottom += fontSize * scale
            contentInsets.left += fontSize * scale
            contentInsets.right += fontSize * scale
            contentInsets = UIEdgeInsetPixelFloor(contentInsets)
            attachment.contentInsets = contentInsets
        }

        let art = NSMutableAttributedString(string: YYTextAttachmentToken)
        art.yy_setTextAttachment(attachment, range: NSMakeRange(0, art.length))
        var ctDelegate = delegate.CTRunDelegate()
        art.yy_setRunDelegate(ctDelegate, range: NSMakeRange(0, art.length))
        if ctDelegate != nil {ctDelegate = nil}
        return art
    }
}

// ÊñáÊú¨‰∏≠ÁöÑÂõæÁâá(ÈúÄË¶ÅÁΩëÁªú‰∏ãËΩΩ)
class WBTextImageViewAttachment: YYTextAttachment {
    var size: CGSize?
    var imageURL: NSURL?
    private var imageView: AnyObject?
    
    override var content: AnyObject! {
        get {
            // Èùû‰∏ªÁ∫øÁ®ãËøîÂõû
            if pthread_main_np() == 0 {return nil}
            if self.imageView != nil {return self.imageView}
            
            // ÂÆåÊàêÊñáÊú¨Ê∏≤ÊüìÂêéÔºåËøõË°åÂõæÁâáÂàùÂßãÂåñÂíå‰∏ãËΩΩ
            let cImageView = UIImageView()
            cImageView.size = self.size!
            cImageView.kf_setImageWithURL(self.imageURL!, placeholderImage: nil)
            self.imageView = cImageView
            return self.imageView
        }
        set(content) {
            self.imageView = UIImageView()
            self.imageView = content
        }
    
    }
}

/// ÊñáÊú¨ÁöÑËΩ¨Âèë(‰æãÂ¶ÇÂ≠ó‰ΩìÔºå‰∏ä‰∏ãÁïôÁôΩ)
class WBTextLinePositionModifier: NSObject, YYTextLinePositionModifier {
    var font: UIFont?
    var paddingTop: Float? = 0
    var paddingBottm: Float? = 0
    var lineHeightMultiple: Float? = 0
    
    override init () {
        let kSystemVersion: Float! = Float(UIDevice.currentDevice().systemVersion)
        if kSystemVersion >= 9 {
            self.lineHeightMultiple = 1.34
        } else {
            self.lineHeightMultiple = 1.3125
        }
    }
    
    func heightForLineCount(lineCount: Int?) -> Float? {
        if lineCount == 0 { return 0 }
        let ascent: CGFloat! = self.font!.pointSize * 0.86
        let decent: CGFloat! = self.font!.pointSize * 0.14
        let lineHeight: CGFloat! = self.font!.pointSize * CGFloat(self.lineHeightMultiple!)
        return self.paddingTop! + self.paddingBottm! + Float(ascent + decent + CGFloat(CGFloat(lineCount! - 1) * lineHeight))
    }
    
    @objc func modifyLines(lines: [AnyObject]!, fromText text: NSAttributedString!, inContainer container: YYTextContainer!) {
        
        let ascent: CGFloat? = self.font?.ascender
        let lineHeight: CGFloat = self.font!.pointSize * CGFloat(self.lineHeightMultiple!)
        
        for line: YYTextLine in lines as! [YYTextLine] {
            var position: CGPoint = line.position
            position.y = CGFloat(self.paddingTop!) + ascent! + CGFloat(line.row) * lineHeight
            line.position = position
        }
    }
    
    @objc func copyWithZone(zone: NSZone) -> AnyObject {
        let one: WBTextLinePositionModifier = WBTextLinePositionModifier()
        one.font = self.font
        one.paddingTop = self.paddingTop
        one.paddingBottm = self.paddingBottm
        one.lineHeightMultiple = self.lineHeightMultiple
        return one
    }
}


